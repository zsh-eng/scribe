---
import Layout from "../layouts/Layout.astro";
import BudgetTreemapGraph from "../components/budgets/BudgetTreemapGraph.astro";
import SectorTrendChart from "../components/budgets/SectorTrendChart.astro";
import fs from "node:fs";
import path from "node:path";
import { hierarchy, treemap, treemapSquarify } from "d3-hierarchy";

const csvPath = path.join(
  process.cwd(),
  "..",
  "data",
  "GovernmentTotalExpenditure.csv",
);
const csvText = fs.readFileSync(csvPath, "utf-8");

function parseCSV(text: string) {
  const lines = text.trim().split("\n");
  return lines
    .slice(1)
    .map((line) => {
      const values: string[] = [];
      let current = "";
      let inQuotes = false;
      for (const char of line) {
        if (char === '"') {
          inQuotes = !inQuotes;
          continue;
        }
        if (char === "," && !inQuotes) {
          values.push(current.trim());
          current = "";
          continue;
        }
        current += char;
      }
      values.push(current.trim());
      return {
        year: parseInt(values[0]),
        estimateType: values[1],
        sector: values[2],
        ministry: values[3],
        expType: values[4],
        amount: parseFloat(values[5]) || 0,
      };
    })
    .filter((r) => !isNaN(r.year));
}

const rows = parseCSV(csvText);

const estimateTypePriority: Record<string, number> = {
  Estimated: 1,
  Revised: 2,
  Actual: 3,
};

const preferredEstimateTypeByYear = new Map<number, string>();
for (const row of rows) {
  const existing = preferredEstimateTypeByYear.get(row.year);
  if (!existing) {
    preferredEstimateTypeByYear.set(row.year, row.estimateType);
    continue;
  }
  const existingPriority = estimateTypePriority[existing] || 0;
  const rowPriority = estimateTypePriority[row.estimateType] || 0;
  if (rowPriority > existingPriority) {
    preferredEstimateTypeByYear.set(row.year, row.estimateType);
  }
}

const filteredRows = rows.filter(
  (row) => preferredEstimateTypeByYear.get(row.year) === row.estimateType,
);

const yearMap = new Map<
  number,
  Map<
    string,
    {
      sector: string;
      ministry: string;
      operating: number;
      development: number;
      estimateType: string;
    }
  >
>();

for (const row of filteredRows) {
  if (!yearMap.has(row.year)) yearMap.set(row.year, new Map());
  const entries = yearMap.get(row.year)!;
  const key = `${row.sector}|||${row.ministry}`;
  if (!entries.has(key)) {
    entries.set(key, {
      sector: row.sector,
      ministry: row.ministry,
      operating: 0,
      development: 0,
      estimateType: row.estimateType,
    });
  }
  const entry = entries.get(key)!;
  if (row.expType === "Operating") entry.operating += row.amount;
  else if (row.expType === "Development") entry.development += row.amount;
}

const W = 1000;
const H = 600;

const sectorOrder = [
  "Social Development",
  "Security and External Relations",
  "Economic Development",
  "Government Administration",
];

interface MinistryCell {
  name: string;
  value: number;
  operating: number;
  development: number;
  x0: number;
  y0: number;
  x1: number;
  y1: number;
}

interface SectorCell {
  name: string;
  value: number;
  x0: number;
  y0: number;
  x1: number;
  y1: number;
  ministries: MinistryCell[];
}

interface YearData {
  total: number;
  estimateType: string;
  sectors: SectorCell[];
}

const allTreemapData: Record<string, YearData> = {};

for (const [year, entries] of yearMap) {
  const entryList = [...entries.values()];

  const sectorGroups: Record<
    string,
    { name: string; value: number; operating: number; development: number }[]
  > = {};
  for (const e of entryList) {
    const total = e.operating + e.development;
    if (total <= 0) continue;
    if (!sectorGroups[e.sector]) sectorGroups[e.sector] = [];
    sectorGroups[e.sector].push({
      name: e.ministry,
      value: total,
      operating: e.operating,
      development: e.development,
    });
  }

  const children = sectorOrder
    .filter((s) => sectorGroups[s]?.length > 0)
    .map((s) => ({
      name: s,
      children: sectorGroups[s],
    }));

  if (children.length === 0) continue;

  const root = hierarchy({ name: "Budget", children })
    .sum((d: any) => d.value)
    .sort((a, b) => (b.value || 0) - (a.value || 0));

  treemap()
    .size([W, H])
    .tile(treemapSquarify)
    .paddingTop((d: any) => (d.depth === 0 ? 0 : 18))
    .paddingRight((d: any) => (d.depth === 0 ? 0 : 3))
    .paddingBottom((d: any) => (d.depth === 0 ? 0 : 3))
    .paddingLeft((d: any) => (d.depth === 0 ? 0 : 3))
    .paddingInner(2)(root as any);

  const totalBudget = root.value || 0;

  const sectors: SectorCell[] = (root.children || []).map((s: any) => ({
    name: s.data.name,
    value: s.value,
    x0: s.x0,
    y0: s.y0,
    x1: s.x1,
    y1: s.y1,
    ministries: (s.children || []).map((m: any) => ({
      name: m.data.name,
      value: m.value,
      operating: m.data.operating,
      development: m.data.development,
      x0: m.x0,
      y0: m.y0,
      x1: m.x1,
      y1: m.y1,
    })),
  }));

  allTreemapData[year] = {
    total: totalBudget,
    estimateType: entryList[0]?.estimateType || "Actual",
    sectors,
  };
}

const years = Object.keys(allTreemapData)
  .map(Number)
  .sort((a, b) => a - b);
const defaultYear = years[years.length - 1];

interface SectorTrendPoint {
  year: number;
  total: number;
  operating: number;
  development: number;
}

const sectorTrendSeries = sectorOrder
  .map((sector) => {
    const points: SectorTrendPoint[] = years
      .map((year) => {
        const entries = yearMap.get(year);
        let operating = 0;
        let development = 0;
        if (entries) {
          for (const entry of entries.values()) {
            if (entry.sector !== sector) continue;
            operating += entry.operating;
            development += entry.development;
          }
        }
        return {
          year,
          total: operating + development,
          operating,
          development,
        };
      })
      .filter((p) => p.total > 0);

    return { name: sector, points };
  })
  .filter((series) => series.points.length > 0);
---

<Layout
  title="Budgets"
  description="Singapore Government Budget Expenditure Treemap"
>
  <header class="mb-6">
    <span class="section-label">Government Expenditure</span>
    <h1 class="page-title">Budget</h1>
    <p class="body-prose max-w-prose">
      How Singapore allocates its expenditure across sectors and ministries.
    </p>
  </header>

  <BudgetTreemapGraph
    data={allTreemapData}
    width={W}
    height={H}
    years={years}
    defaultYear={defaultYear}
  />

  <SectorTrendChart trendSeries={sectorTrendSeries} years={years} />

  <p class="font-sans text-xs text-ink-muted mt-4">
    Source: Singapore Government Total Expenditure, data.gov.sg. Amounts in S$
    millions.
  </p>
</Layout>
